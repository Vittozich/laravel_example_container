My docker example for the local laravel + react (or other frontend library) projects.

### `OCTOBER 2020`

### `difficulty level: 2 of 10`

# Components: 

- [php:7.4-fpm-alpine](https://registry.hub.docker.com/_/php) (build)
- [mysql:8](https://registry.hub.docker.com/_/mysql) (image)
- [nginx:stable-alpine](https://hub.docker.com/_/nginx) (image)
- [phpmyadmin/phpmyadmin](https://registry.hub.docker.com/r/phpmyadmin/phpmyadmin) (image)
- [composer:latest](https://registry.hub.docker.com/_/composer) (build as php but +)
- [library/node](https://registry.hub.docker.com/_/node) (image, npm)

# `EN`:

# commands:


<hr/>

# notes:


<hr/>


# `RU`:


# Команды:

- `docker-compose build && docker-compose up -d` - создание контейнера 
(его запуск и по этой команде можно пересоздавать(после изменений))

- `docker-compose up -d --build` - другая версия той же команды 
- `docker-compose down` - удаляет контейнеры

<hr/>

# Пометки:

## Установки после клонирования репозитория:

 - копировать `.env.example` в `.env`
 - Если папки не создались - создать папки `mysql` и `src`
 - Проверить работоспособность контейнера можно создав файл по пути `src/public/index.php` (написать там что-то) и запустив в браузере `localhost/`
 - Для использования данной сборки контейнеров на боевом сервере её нужно немного переконфигурировать
 - не забыть поставить параметры базы данных в проекте и в докере - чтобы они не отличались

## По работе проекта:

- Для того, чтобы собирать данные контейнеры для разных приложений в `.env` стоит назвать `APP_NAME`,
 чтобы для каждого проекта были свои контейнеры. Лучше называть с нижним подчеркиванием в начале
- Если нужно запустить разные сборки контейнеров одновременно - нужно поменять порты сервисов (контейнеров) во избежание конфликтов
- Возможности общего шаблона будут дополнены после проверки его на всех моих проектах (дополнительные либы для php и дополнительные контейнеры (типо phpmyadmin))
- Данный контейнер собирается, как группа контейнеров, которые описаны в `docker-compose.yml`
- Код фреймворка (Laravel) находится в папке `src` и `.gitignore` игнорирует то, 
что внутри, так как внутри данной папки - репозиторий `git` фреймворка (как проекта)
- В данной сборке используется `nginx`, но можно использовать и настроить `apache` -
механизм не будет отличаться, при обновлении файлов внутри `src` не нужно перезапускать контейнеры.
- ВАЖНО: все эти настройки - для локальной работы с проектом, для боевой версии немного другая конфигурация. (возможно, для каждого сервера своя)

## Конфигурация образа в отдельном файле:

- Вместо `image` в `docker-compose.yml` используется синтаксис `build` и внутри `build:` 
2 переменные `context` - где этот файл искать (`./php`) и `dockerfile` - название докерфайла. (лучше это сделать в отдельной папке)

## Конфигурация mysql:

- База данных работает сначала с одной таблицей, с одним пользователем, который имеет доступ на чтение только одной базы
- При конфигурации базы данных в проекте необходимо указать начальную базу данных как в настройках `.env` проекта (в папке `src`)
 и изменить подключение с `localhost` или с `127.0.0.1` на название базы контейнера (в данном случае `mysql`)
 и это выглядит так:
 
        DB_HOST=mysql
        DB_USERNAME=mysql
        DB_PASSWORD=mysql
        
- Если проект содержит несколько баз данных, их надо создать или копировать (если проект переносится на docker)
 и добавить права стандартному пользователю (в данном случае пользователю `mysql`)

## Конфигурация nginx:

- Создается отдельный файл конфигурации в папке `./nginx` с названием `default.conf`  -
 данные об этом указываются в настройке контейнера в `docker-compose.yml` в настройках nginx в `volumes`

## Работа с composer контейнером:

- После билда этот контейнер в состоянии отключенного.
- Выполнять команды для composer нужно с префиксом `--rm` - так как composer создает команду, по выполнении которой - команда должна быть удалена. 
Иначе будет создан ещё один контейнер. Пример - узнать версию `docker-compose run --rm composer -V`
- Данный контейнер в стандартной сборке использует совсем урезанную версию `php` с которой невозможны большинство моих проектов, поэтому я собираю билд.
- Важно понимать что `php`, который используется внутри стандартной сборки `composer` это не тот же самый, что используется в текущем контейнере `php`, ещё раз повторю, это причина почему я собираю билд.
- Внутри папки `./php/composer` есть файл `php.ini` он нужен для настроек всех образов `php`  в данной группе контейнеров

## Работа с npm контейнером:

- Так же с префиксом `--rm` выполнять команды

## Работа с artisan контейнером:

- Так же с префиксом `--rm` выполнять команды
- Условие - проект должен лежать в папке src (без laravel проекта контейнер будет создан, но не будет работать, будет выдавать ошибку)
- пример узнать версию `docker-compose run --rm artisan -V` 

## Работа с одновременно запущенными контейнерами, если они связаны

- не достаточно просто изменить порты и обращаться по имени контейнера вместо url
- Для создания моста между 2 группами контейнеров нужно создать новый `network`, это будет выглядеть так
     
      networks:
        laravel:
        app-shared:
          driver: bridge
          
- Данный `network` нужно указать в `networks` контейнеров `nginx` и `php`
- Для того, чтобы использовать этот `network` в другом приложении необходимо узнать его точно имя,
оно указывается при создании контейнера, в моём случае это `laravel_example_container_app-shared` ,
можно проследить и предугадать как именно создается имя, но учитывая синтаксис (без точек и символов в верхнем регистре)
- Вот так это будет выглядеть в проекте `приемнике` запросов (не забыть присвоить этот `network` Для  `nginx` и `php` второго проекта)
      
      networks:
          laravel:
          laravel_example_container_app-shared:
            external: true

<hr/>